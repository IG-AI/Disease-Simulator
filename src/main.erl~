-module(main).
-export([get_master/2,spawn_people/2]).

-type person() :: {status(),integer(),integer()}.
-type state() :: [{pid(),person()}].
-type status() :: integer().

-include_lib("eunit/include/eunit.hrl").

-spec get_master(Num :: integer(),Times :: integer()) -> done.
get_master(Num, Times) ->   
    State  = spawn_people([],Num),   
    register(master, self()),
    master(State, Times).

-spec master(State :: state(), Times :: integer()) -> done.
master(_, 0) ->
    unregister(master),
    done;

master(State, Times) ->     
    master_call_all(State),
    receive
        {result, New_state} ->      
            io:format("State: ~p ~n", [New_state]),
            master(New_state, Times-1)
    end.

-spec master_call_all(State :: state()) -> {result,state()}.
master_call_all(State) ->
    send_to_all(ready, State),
    master_wait(State, length(State)).

-spec master_wait(State :: state(), Num :: integer()) -> {result,state()}.
master_wait(State, Num) ->
    wait_fun(State, master, Num).


-spec wait_fun(State :: state(), Receiver :: pid(), Num :: integer()) -> {result,state()}.
wait_fun(State, Receiver, 0) ->  
    Receiver ! {result, State};
  
wait_fun(State, Receiver, Num) ->
    receive
       {work, {PID, Value}} ->
            New_state = lists:keyreplace(PID, 1, State, {PID,Value}),
            wait_fun(New_state, Receiver, Num-1)
    end.

-spec spawn_people(State :: state(), N :: integer()) -> state().
spawn_people(State, 0) ->
    State;

spawn_people(State, N) ->
    S = 0,
    X =  rand:uniform(10),
    Y = rand:uniform(10),
    PID = spawn(fun() -> people({S,X,Y}) end),
    spawn_people([{PID,{S,X,Y}} | State], N-1).

-spec people(person()) -> any().
people({S,X,Y}) ->
    receive
        ready ->           
            {X2, Y2} = new_rand_position(X,Y),           
            master ! {work, {self(), {S,X2,Y2}}},            
            people({S,X2,Y2})
    end.


-spec new_position(X :: integer(), Y :: integer(),Position :: integer()) -> {integer(),integer()}.
new_position(X,Y,Position) ->
    case Position of 
        1 ->
            {X-1, Y+1};
        2 ->
            {X, Y+1};
        3 ->
            {X+1, Y+1};
        4 ->
            {X-1, Y};
        5 ->
            {X, Y};
        6 ->
            {X+1, Y};
        7 ->
            {X-1, Y-1};
        8 ->
            {X, Y-1};
        9 ->
            {X+1, Y-1}
        end.

-spec new_rand_position(X :: integer(), Y :: integer()) -> {integer(),integer()}.
new_rand_position(X,Y) ->
    new_position(X,Y,rand:uniform(9)).

-spec send_to_all(Msg :: term(),state()) -> ok.
send_to_all(_, []) ->
    ok;

send_to_all(Msg, [{PID,_} | Elems]) ->
    PID ! Msg,
    send_to_all(Msg, Elems).  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                         EUnit Test Cases                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


new_position_test() ->
    [?assertEqual(new_position(10,10,1),{9,11}),
     ?assertEqual(new_position(10,10,2),{10,11}),
     ?assertEqual(new_position(10,10,3),{11,11}),
     ?assertEqual(new_position(10,10,4),{9,10}),
     ?assertEqual(new_position(10,10,5),{10,10}),
     ?assertEqual(new_position(10,10,6),{11,10}),
     ?assertEqual(new_position(10,10,7),{9,9}),
     ?assertEqual(new_position(10,10,8),{10,9}),
     ?assertEqual(new_position(10,10,9),{11,9})].

spawn_people_test() ->
    ?assertEqual(length(spawn_people([],5)),5).
     

wait_fun_test() ->    
    Test_state =  [{self(),1}],
    PID = spawn(fun() -> wait_fun(Test_state,self(),0) end),
    receive
        {result,_} ->
            ?assertEqual(a,[{self(),1}])                  
    end.
   

    
































%% rek(P, 0) ->
%%     done3;

%% rek(P,T) ->
%%     io:format("Result ~p: ~p ~n", [T,rec(P,0)]),
%%     rek(P,T-1).

%% rec(0,Acc) ->
%%    Acc;

%% rec(Value,Acc) ->
%%     rec(Value -1,Acc + rand:uniform(50)).
